webpackJsonp([57938557541115],{308:function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function a(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}t.__esModule=!0;var o=n(1),i=a(o),s=n(47),l=(r(s),n(34)),c=(n(24),n(38));t.default=function(){return i.createElement("div",null,i.createElement(l.Section,{title:"Fetching Data with GraphQL"},i.createElement("p",null,"First of all, we need to add the GraphQL plugin to our application’s config file:"),i.createElement(c.CodeFile,{path:"src/config.ts"},n(658)),i.createElement("p",null,"Next, we write a query. Let’s assume for now that we have a GraphQL backend capable of fulfilling this query."),i.createElement("p",null,"In this example, we declare that we want to fetch the first ane last name of a specific user. The user’s ID is provided as a parameter to the query."),i.createElement(c.CodeFile,{path:"src/pages/UserPage/UserPage.graphql"},n(659)),i.createElement("p",null,"Next, let's create a page that uses this query. We use the ",i.createElement("code",null,"@query")," decorator to attach the query to a component. This adds a service to the page that transparently handles fetching data before the component is rendered and reacting to changes to the underlying data."),i.createElement(c.CodeFile,{path:"src/pages/UserPage/UserPage.tsx"},n(660)),i.createElement("p",null,"[TODO] It is important to ensure that our component only uses properties that are declared in the query. Luminant will automatically generate typescript files describing the expected query params and the data returned from query. It is your responsibility to ensure that these are imported into the component and included in the type.")),i.createElement(l.Section,{title:"How Data Fetching Works"},i.createElement("p",null,"In React, we are used to reacting to component lifecycle events. Hooks such as ",i.createElement("code",null,"componentWillMount"),",",i.createElement("code",null,"componentDidMount")," and ",i.createElement("code",null,"componentDidReceiveProps")," are typically used to fetch data, create and update remote resources, etc."),i.createElement("p",null,"Luminant services, in addition to some having their own versions of many of these lifecycle hooks, also understand additional hooks. These differ from React lifecycle hooks, in that they can be asynchronous."),i.createElement("p",null,"If a service implements ",i.createElement("code",null,"serviceWillLoad"),", this will be called whenever:"),i.createElement("ul",null,i.createElement("li",null,"A page containing the service is visited. The page will not be rendered until all services that respond to loading hooks have resolved."),i.createElement("li",null,"A component containg the service is added to the page. The component will not be rendered until services that belong to it or child components have resolved."),i.createElement("li",null,"[TODO] The props of a component containing the service change.")),i.createElement("p",null,"Loading hooks are called in order. A child component will not load until its parents have finished loading."),i.createElement("p",null,"Loading hooks on plugins are called once when the application loads. They are not called for subsequent page transitions. These can be useful for doing things like validating authentication credentials."),i.createElement("p",null,"Throwing an exception in a load hook aborts the loading process. Exceptions do not currently stop the application from rendering. This may change in the future."),i.createElement("p",null,"It is currently an error to read or write from a Service's state during a load hook. Fetched data should be written to the application's store using the dispatcher."),i.createElement("p",null,"The recommended pattern for handling non-fatal errors is to catch them as they happen, save them to the application's store, then re-throw when rendering. This allows users of your service to use React's error handling pattern (",i.createElement("code",null,"componentDidCatch"),")")),i.createElement(l.Section,{title:"Writing a data-fetching service"},i.createElement("p",null,"In this example, we."),i.createElement("p",null,"First we write a service. It needs a plugin to manage the fetched data and cache it at application level and a service to resolve data dependencies for annotated controllers."),i.createElement("p",null,"As described above, network and http errors are caught as they occur and then re-thrown to users of the component when they attempt to retrieve the data."),i.createElement(c.CodeFile,{path:"src/plugins/SimpleHttpFetcher.ts"},n(682)),i.createElement("p",null,"This service can now be used simply to annotate components with a URL to fetch JSON data from."),i.createElement(c.CodeFile,{path:"src/pages/UserPage/UserPage.tsx"},n(681))))},e.exports=t.default},658:function(e,t){e.exports='{\n  "plugins": {\n    "@brightinteractive/bright-js-framework/plugins/graphql": {}\n  }\n}\n'},659:function(e,t){e.exports="query UserPage($id: String!) {\n  user(id: $id) {\n    firstName\n    lastName\n  }\n}\n"},660:function(e,t){e.exports="import * as React from 'react'\nimport { route, controller } from '@brightinteractive/bright-js-framework'\nimport { query, GraphQLQuery } from '@brightinteractive/bright-js-framework/plugins/graphql'\nimport * as PageQuery from './UserPage.graphql'\n\n@route('/users/:id')\n@controller()\nexport class UserPage extends React.PureComponent {\n  @query(PageQuery)\n  query: GraphQLQuery<any>\n\n  render() {\n    return (\n      <div>\n        First Name: {this.query.data.user.firstName}<br />\n        Last Name: {this.query.data.user.lastName}<br />\n      </div>\n    )\n  }\n}\n"},681:function(e,t){e.exports="import * as React from 'react'\nimport { controller, route } from '@brightinteractive/bright-js-framework'\nimport { get, HttpGet } from '../../plugins/SimpleHttpFetcher'\n\ninterface User {\n  firstName: string\n  lastName: string\n}\n\n@route('/me')\n@controller()\nexport class UserPage extends React.PureComponent {\n  @get('http://my-api.com/me')\n  query: HttpGet<User>\n\n  render() {\n    return (\n      <div>\n        First Name: {this.query.data.firstName}<br />\n        Last Name: {this.query.data.lastName}<br />\n      </div>\n    )\n  }\n}\n"},682:function(e,t){e.exports="import { Service, PluginConfig, service, state, select, dispatcher, Dispatcher, StateSelection } from '@brightinteractive/bright-js-framework'\n\n// Key identifying HTTP state\nconst HTTP_STATE = 'http-data'\n\n// Cached HTTP resources\ntype HttpState = Record<string, HttpResource>\n\n// Action describing result of http fetch\ntype HttpResource\n  = { status: 'error', error: Error }\n  | { status: 'completed', data: any }\n\n// Public service interface\nexport interface HttpGet<T> {\n  readonly data: T\n}\n\n// Decorator used to install service on a controller\nexport function get(url: string): PropertyDecorator {\n  const resourceState = (data: any): HttpState => data[HTTP_STATE][url]\n\n  class HttpGetService extends Service implements HttpGet<any> {\n    @dispatcher()\n    private dispatch: Dispatcher<SimpleHttpFetcherAction>\n\n    @select(resourceState)\n    private resourceState: StateSelection<HttpResource>\n\n    get data() {\n      // Throw fetch errors when the user attempts to get the data.\n      // This can be caught using React's componentWillCatch method.\n      if (this.resourceState.value.status === 'error') {\n        throw this.resourceState.value.error\n      }\n\n      return this.resourceState.value.data\n    }\n\n    async serviceWillLoad() {\n      // Don't refetch data that is already fetched\n      if (this.resourceState) {\n        return\n      }\n\n      try {\n        const result = await fetch(url)\n        if (!result.ok) {\n          throw new Error(result.statusText)\n        }\n\n        this.dispatch({\n          type: 'http:fetch:completed',\n          url,\n          payload: await result.json()\n        })\n\n      } catch (error) {\n        this.dispatch({\n          type: 'http:fetch:failed',\n          url,\n          error\n        })\n      }\n    }\n  }\n\n  return service(HttpGetService)\n}\n\ntype SimpleHttpFetcherAction\n  = { type: 'http:fetch:completed', url: string, payload: any }\n  | { type: 'http:fetch:failed', url: string, error: Error }\n\nexport default class SimpleHttpFetcherPlugin extends PluginConfig {\n  @state(HTTP_STATE)\n  static updateState(prev: HttpState = {}, action: SimpleHttpFetcherAction): HttpState {\n    if (action.type === 'http:fetch:completed') {\n      return {\n        ...prev,\n        [action.url]: {\n          status: 'completed',\n          data: action.payload\n        }\n      }\n    }\n\n    if (action.type === 'http:fetch:failed') {\n      return {\n        ...prev,\n        [action.url]: {\n          status: 'error',\n          error: action.error\n        }\n      }\n    }\n\n    return prev\n  }\n}\n"}});
//# sourceMappingURL=component---src-pages-docs-fetching-data-js-02757d630fde3c6eb7d9.js.map