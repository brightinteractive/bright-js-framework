webpackJsonp([77055595419222],{307:function(e,n,t){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function a(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n.default=e,n}n.__esModule=!0;var o=t(1),i=a(o),s=t(47),l=r(s),c=t(34),p=t(24),u=t(38);n.default=function(){return i.createElement("div",null,i.createElement(p.PageHeader,null,"Using Plugins"),i.createElement(c.Section,{title:"Introduction"},i.createElement("p",null,"Previously, we looked at ",i.createElement(l.default,{to:"/services-and-controllers"},"services"),", which allow behaviours to be extracted out of controller components and shared."),i.createElement("p",null,"Sometimes, we want to attach behavior to the ",i.createElement("em",null,"whole application"),". Plugins provide a way of doing this. Some uses of Plugins are:"),i.createElement("ul",null,i.createElement("li",null,"When integrating an authentication provider, we might need to retrieve and validate an auth token when the application loads for the first time, before we decide what page to render."),i.createElement("li",null,"When integrating a data store such as Redux, we would need to keep a single store instance at the root of applications and allow our services and controllers access to the store."),i.createElement("li",null,"When writing a controller that interfaces with DOM APIs, we may want to use that controller in environments where the DOM does not exist. For example, a controller that reads or writes to cookies that we wish to use in a server-side-rendered application would need an abstract interface to access cookies, looking in the HTTP request in a server app, or a DOM API in the browser. It might also need a stub implementation when running in a test environment."),i.createElement("li",null,"When writing a GraphQL API for an application, we might want to add a GraphQL endpoint to our application server (assuming that we aren’t using an external GraphQL API).")),i.createElement("p",null,"Plugins provide a simple way of achieving these tasks.")),i.createElement(c.Section,{title:"Using plugins"},i.createElement("p",null,"Plugins are picked up from the default exports of source files in a conventional directory in your project. By default, this is ",i.createElement("code",null,"src/plugins"),"."),i.createElement("p",null,"Sometimes, you will want to use plugins that live in external modules. Some of these may allow or require configuration. This can be done by adding the plugin, along with any configuration, to your ",i.createElement("code",null,"luminant.json")," file. For example, here is how Luminant's GraphQL plugin is installed and configured:"),i.createElement(u.CodeFile,{path:"luminant.json"},t(155)),i.createElement("p",null,"Some plugins provide an API to controllers. Others may have application-wide effects that do not require any usage. Consult the documentation for the specific plugin for further usage instructions.")),i.createElement(c.Section,{title:"Writing plugins that provide injectable dependencies"},i.createElement("p",null,"One usecase for plugins is to configure dependencies that are injected into controllers and services on request."),i.createElement("p",null,"Plugins that allow dependencies to be injected into components will typically provide a decorator to inject the dependency and an interface for the dependency as an API. A controller that uses a hypothetical ",i.createElement("code",null,"EventManager")," plugin to dispatch events might use it as follows:"),i.createElement(u.CodeFile,{path:"src/components/ControlPanel.tsx"},t(672)),i.createElement("p",null,"It is important to understand the difference between injected objects and services. Although the APIs are similar, they serve very different purposes. Objects injected by plugins are shared across the whole application. This differs from services, which are unique to each controller. So for an event system, which requires all clients to share a single underlying object, we would use a plugin to provide the event manager. For a form-binding helper, which is a piece of extracted controller logic, we would use a service."),i.createElement("p",null,"Writing a plugin entails creating a plugin configuration to export the dependencies the plugin provides. This is done by extending the ",i.createElement("code",null,"PluginConfig")," class, and utilising the",i.createElement("code",null,"@exported")," decorator."),i.createElement(u.CodeFile,{path:"src/plugins/EventManagerPlugin.ts"},t(673)),i.createElement("p",null,"In this code block we have created an extremely simple event manager plugin. The event manager itself is just an object; what's special here is the use of the ",i.createElement("code",null,"@exported")," decorator to allow the ",i.createElement("code",null,"EventManager")," to be injected into controllers and services."),i.createElement("p",null,"The ",i.createElement("code",null,"@exported")," decorator takes one parameter: a string key. This registers the value of the decorated property as an available dependency with the given key. Any controllers or services can request this dependency by providing the same key to the ",i.createElement("code",null,"@inject")," decorator."),i.createElement("p",null,"To abstract the details of the key away from the users of our plugin, we've exported a decorator named",i.createElement("code",null,"@eventManager"),". In this case, this is simply ",i.createElement("code",null,"@inject")," with a prefilled key. This does, however, give us (the plugin authors) the freedom to change how the clients of the plugin receive the EventManager. In the future, we may wish to do more than just a simple inject; we may also wish to utilise ",i.createElement("code",null,"@service")," capabilities, for example.")),i.createElement(c.Section,{title:"Writing plugins that manage application state"},i.createElement("p",null,"Sometimes components need to access and modify state that isn’t scoped to a particular view and is therefore not appropriate to manage using a component or service."),i.createElement("p",null,"A second function of plugins is to allow the management of application-level state, while allowing components to subscribe to state changes using the ",i.createElement("code",null,"@select()")," decorator."),i.createElement("p",null,"The approach used will be familiar to you if you have used ",i.createElement("a",{href:"https://redux.js.org/"},"Redux")," before. ",i.createElement("em",null,"Action")," objects describing a state modification are dispatched, then applied to the previous state using a ",i.createElement("em",null,"reducer")," function. Components subscribe to a part of the application state by applying a ",i.createElement("em",null,"selector")," function to the application's state object."),i.createElement("p",null,"This structured approach to application state is helpful in large applications, as isolating state modification from the rest of the application makes state easier to reason about."),i.createElement("p",null,"In Bright-js-framework, each reducer function manages a discrete part of the application state identified by a key. Reducers are defined as static methods on plugins, decorated with ",i.createElement("code",null,"@state()"),"."),i.createElement(u.CodeFile,{path:"src/plugins/CounterPlugin.ts"},t(675)),i.createElement("p",null,"A component developer would then use this API as follows:"),i.createElement(u.CodeFile,{path:"src/components/Counter.tsx"},t(674))),i.createElement(c.Section,{title:"Distributing plugins that require configuration"},i.createElement("p",null,"When a plugin is distributed as a node module, it may require configuration from the application it is used in (for example, a plugin implementing an authentication provider will need API keys, an auth endpoint, etc providing to it)."),i.createElement("p",null,"If the default export of a plugin file is a factory function that returns a PluginConfig class (as opposed ot exporting a PluginConfig class directly), this function will receive any options provided to the plugin in the application’s ",i.createElement("code",null,"luminant.json"),"."),i.createElement("p",null,"In this (slightly contrived) example, we write a plugin designed to be distributed as a node module that throw an exception when the application loads. It helpfuly allows users to pass in the message that is thrown as a configuration value:"),i.createElement(u.CodeFile,{path:"throw-error-on-load/index.ts"},t(680)),i.createElement("p",null,"A user of the plugin can now reference it in their ",i.createElement("code",null,"luminant.json")," (in this example via a relative path. Typically it will be the name of a node module):"),i.createElement(u.CodeFile,{path:"app/luminant.json"},t(679))),i.createElement(c.Section,{title:"Writing plugins that bundle additional source files"},i.createElement("p",null,"[TODO]"),i.createElement("p",null,"Example usage in the GraphQL server:"),i.createElement(u.CodeFile,{path:"plugin-loader.ts"},t(685)),i.createElement(u.CodeFile,{path:"../../lib/plugins/GraphQLServerPlugin/loadSchema"},t(684)),i.createElement(u.CodeFile,{path:"../../lib/plugins/GraphQLServerPlugin/graphQLServerPluginEntry"},t(683))))},e.exports=n.default},155:function(e,n){e.exports='{\n  "plugins": {\n    "@brightinteractive/bright-js-framework/plugins/graphql": {\n      "backendUrl": "$MY_GRAPHQL_BACKEND"\n    }\n  }\n}\n'},672:function(e,n){e.exports="import * as React from 'react'\nimport { controller } from '@brightinteractive/bright-js-framework'\nimport { eventManager, EventManager } from '../plugins/EventManagerPlugin'\n\n@controller()\nexport class ControlPanel extends React.PureComponent {\n  @eventManager\n  eventManager: EventManager\n\n  handleOpenClick = () => {\n    this.eventManager.emit('request-open-pod-bay-doors')\n  }\n\n  componentDidMount() {\n    this.eventManager.registerHandler('request-open-pod-bay-doors', () => {\n      console.error('I’m sorry but I can’t do that, Dave')\n    })\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Pod Bay doors:</h3>\n        <button onClick={this.handleOpenClick}>Open</button>\n      </div>\n    )\n  }\n}\n"},673:function(e,n){e.exports="import {exported, inject, PluginConfig} from '@brightinteractive/bright-js-framework'\n\nconst EVENT_MANAGER = 'eventManager'\n\nexport const eventManager = inject(EVENT_MANAGER)\n\nexport default class EventManagerPlugin extends PluginConfig {\n  @exported(EVENT_MANAGER)\n  eventManager = new EventManager()\n}\n\nexport type EventHandler = (event: any) => void\n\nexport class EventManager {\n  private eventHandlers: Map<string, Set<EventHandler>> = new Map()\n\n  registerHandler(eventKey: string, eventHandler: EventHandler) {\n    const existingHandlers = this.eventHandlers.get(eventKey) || new Set()\n    this.eventHandlers.set(eventKey, existingHandlers.add(eventHandler))\n  }\n\n  emit(eventKey: string, event?: any) {\n    const handlers = this.eventHandlers.get(eventKey)\n    if (!handlers) {\n      return\n    }\n\n    handlers.forEach((eventHandler) => eventHandler(event))\n  }\n}\n"},674:function(e,n){e.exports="import * as React from 'react'\nimport { controller, select, StateSelection } from '@brightinteractive/bright-js-framework'\nimport { CounterActions, counterActions, counterValue } from '../plugins/CounterPlugin'\n\n@controller()\nexport class Counter extends React.PureComponent {\n  @select(counterValue)\n  counterValue: StateSelection<number>\n\n  @counterActions\n  counter: CounterActions\n\n  render() {\n    return (\n      <div>\n        Value: {this.counterValue.value}\n        <button onClick={this.counter.increment}>Increment</button>\n      </div>\n    )\n  }\n}\n"},675:function(e,n){e.exports="import { inject, state, exported, dispatcher, Dispatcher, PluginConfig, Action, SelectFn } from '@brightinteractive/bright-js-framework'\n\nconst COUNTER_ACTIONS = 'counterActions'\nconst COUNTER_STATE = 'counter'\n\nexport interface CounterActions {\n  increment(): void\n}\n\ninterface CounterState {\n  counterValue: number\n}\n\nexport default class CounterPlugin extends PluginConfig<CounterState> {\n  @state(COUNTER_STATE)\n  static update(prev: number = 0, action: Action): number {\n    if (action.type === 'counter:increment') {\n      return prev + 1\n    }\n\n    return prev\n  }\n\n  @dispatcher()\n  dispatch: Dispatcher\n\n  @exported(COUNTER_ACTIONS)\n  actions: CounterActions = {\n    increment: () => {\n      this.dispatch({ type: 'counter:increment' })\n    }\n  }\n}\n\n// Exported API to inject the action objects into a service or controller\nexport const counterActions = inject(COUNTER_ACTIONS)\n\n// Exported API to bind a selected state value into a service or controller\nexport const counterValue: SelectFn<number> = (appState) => appState[COUNTER_STATE]\n"},679:function(e,n){e.exports='{\n  "plugins": {\n    "../throw-error-on-load": {\n      "message": "YOU SHALL NOT PASS"\n    }\n  }\n}\n'},680:function(e,n){e.exports="import { PluginConfig } from '@brightinteractive/bright-js-framework'\n\nexport interface ThrowErrorOnLoadPluginOptions {\n  message: string\n}\n\nexport default function createThrowErrorOnLoadPlugin({ message }: ThrowErrorOnLoadPluginOptions) {\n  class ThrowErrorOnLoadPlugin extends PluginConfig {\n    serviceWillMount() {\n      throw new Error(message)\n    }\n  }\n\n  return ThrowErrorOnLoadPlugin\n}\n"},683:function(e,n){e.exports="import { RequestHandler } from 'express'\nimport { graphqlExpress, graphiqlExpress } from 'graphql-server-express'\nimport * as bodyParser from 'body-parser'\nimport { PluginConfig, decorateRequestHandler, PluginConstructor } from '../../core/PluginConfig'\nimport { RequireList, isSubclassOf, getEntrypointExports, RequireFn } from '../../bundler/Entrypoint'\nimport { Connector } from './Connector'\nimport { GraphQLServer } from './GraphQLServer'\nimport { isSchemaType } from './Resolver'\n\nconst serverMiddleware = [\n  bodyParser.json()\n]\n\nexport interface GraphQLPluginOpts {\n  connectors: RequireList\n  schemas: Array<{ typeDefs: RequireFn, resolvers: RequireList}>\n}\n\nexport default function graphQLServerPluginEntry({ connectors, schemas }: GraphQLPluginOpts): PluginConstructor {\n  const server = new GraphQLServer({\n    connectors: getEntrypointExports(connectors, isSubclassOf(Connector)),\n    schema: schemas.map(({ typeDefs, resolvers }) => ({\n      typeDefs: typeDefs(),\n      resolvers: getEntrypointExports(resolvers, isSchemaType)\n    })),\n  })\n\n  class GraphQLServerPlugin extends PluginConfig {\n    @decorateRequestHandler('/graphql', { method: 'POST', middleware: serverMiddleware })\n    static handleGraphQLRequest?: RequestHandler = createServer()\n  }\n\n  class DevelopmentGraphQLServerPlugin extends GraphQLServerPlugin {\n    @decorateRequestHandler('/graphql-ui', { method: 'GET' })\n    static handleGraphQLUIRequest?: RequestHandler = createUI()\n  }\n\n  function createServer() {\n    return server.requestConfig && graphqlExpress(server.requestConfig)\n  }\n\n  function createUI() {\n    return graphiqlExpress({\n      endpointURL: '/graphql'\n    })\n  }\n\n  if (process.env.NODE_ENV === 'production') {\n    return GraphQLServerPlugin\n  } else {\n    return DevelopmentGraphQLServerPlugin\n  }\n}\n"},684:function(e,n){e.exports="import * as path from 'path'\n\nexport interface LoadSchemaOpts {\n  glob: (pattern: string) => string[],\n  resolvePath: (pathname: string) => string\n}\n\nexport interface LoadSchemaResults {\n  connectors: string[],\n  schemas: Array<{ typeDefs: string, resolvers: string[] }>\n}\n\nexport function findGraphQLSources(opts: LoadSchemaOpts): LoadSchemaResults {\n  const schemas = findSchemas(opts)\n\n  return {\n    connectors: findConnectors(opts),\n    schemas: schemas.map((schema) => ({\n      typeDefs: schema,\n      resolvers: findResolversForSchema(opts, schema)\n    }))\n  }\n}\n\nfunction findSchemas({ glob, resolvePath }: LoadSchemaOpts) {\n  return glob('src/graphql/schema/**/*.graphql').map(resolvePath)\n}\n\nfunction findResolversForSchema({ glob, resolvePath }: LoadSchemaOpts, schemaPath: string) {\n  return glob(`${path.dirname(schemaPath)}/**/*.ts`).map(resolvePath)\n}\n\nfunction findConnectors({ glob, resolvePath }: LoadSchemaOpts) {\n  return glob('src/graphql/connectors/**/*.ts').map(resolvePath)\n}\n"},685:function(e,n){e.exports="import * as path from 'path'\nimport * as glob from 'glob'\nimport filewatcher = require('filewatcher')\nimport { introspectSchema, generate } from 'apollo-codegen'\nimport { findGraphQLSources } from '../../lib/plugins/GraphQLServerPlugin/loadSchema'\nimport { EntrypointOpts } from '../../lib/bundler/entrypointLoader'\nimport { PluginLoader } from '../../lib/bundler/PluginLoader'\n\nconst pluginFactory = require.resolve('../../lib/plugins/GraphQLServerPlugin/graphQLServerPluginEntry')\n\nexport default class GraphQLPluginLoader extends PluginLoader {\n  private topLevelModules = findGraphQLSources({\n    glob: glob.sync,\n    resolvePath: (pathname) => path.resolve(pathname)\n  })\n\n  /**\n   * Adds GraphQL sources into the application bundle.\n   */\n  configurePluginEntry(): EntrypointOpts | undefined {\n    if (this.environment !== 'server') {\n      return undefined\n    }\n\n    return {\n      entry: pluginFactory,\n      topLevelModules: this.topLevelModules\n    }\n  }\n\n  /**\n   * Generate schema types on build.\n   */\n  async applicationWillBuild() {\n    await this.generateQueryTypes()\n  }\n\n  /**\n   * Server hook. Generate schema types on run and start filewatcher.\n   */\n  async applicationWillStart() {\n    if (process.env.NODE_ENV === 'production') {\n      return\n    }\n\n    await this.generateQueryTypes()\n\n    const watcher = filewatcher()\n    glob.sync('src/**/*.graphql').forEach((file) => {\n      watcher.add(file)\n    })\n\n    watcher.on('change', () => this.generateQueryTypes())\n  }\n\n  /**\n   * Generate typescript interfaces from GraphQL queries.\n   */\n  private async generateQueryTypes() {\n    const { schemas } = this.topLevelModules\n    if (!schemas[0]) {\n      return\n    }\n\n    await introspectSchema(schemas[0].typeDefs, './schema.json')\n\n    glob.sync('src/**/queries').forEach((sourcePath) => {\n      generate(\n        glob.sync(`${sourcePath}/*.graphql`).map((x) => path.resolve(x)),\n        path.resolve('./schema.json'),\n        path.resolve(`${sourcePath}/types.ts`),\n        'typescript',\n        'gql',\n        {\n          passthroughCustomScalars: false,\n          customScalarsPrefix: '',\n          addTypename: false,\n          namespace: '',\n          operationIdsPath: null,\n          generateOperationIds: false,\n          mergeInFieldsFromFragmentSpreads: true\n        }\n      )\n    })\n  }\n}\n"}});
//# sourceMappingURL=component---src-pages-docs-extending-with-plugins-js-4b47d221964fca4af542.js.map