webpackJsonp([77055595419222],{'./node_modules/babel-loader/lib/index.js?{"plugins":["/home/travis/build/brightinteractive/bright-js-framework/docs-site/node_modules/gatsby/dist/utils/babel-plugin-extract-graphql.js","/home/travis/build/brightinteractive/bright-js-framework/docs-site/node_modules/babel-plugin-add-module-exports/lib/index.js","/home/travis/build/brightinteractive/bright-js-framework/docs-site/node_modules/babel-plugin-transform-object-assign/lib/index.js"],"presets":[["/home/travis/build/brightinteractive/bright-js-framework/docs-site/node_modules/babel-preset-env/lib/index.js",{"loose":true,"uglify":true,"modules":"commonjs","targets":{"browsers":["> 1%","last 2 versions","IE >= 9"]},"exclude":["transform-regenerator","transform-es2015-typeof-symbol"]}],"/home/travis/build/brightinteractive/bright-js-framework/docs-site/node_modules/babel-preset-stage-0/lib/index.js","/home/travis/build/brightinteractive/bright-js-framework/docs-site/node_modules/babel-preset-react/lib/index.js"],"cacheDirectory":true}!./src/pages/docs/extending-with-plugins.js':function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function r(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}t.__esModule=!0;var a=n("./node_modules/react/react.js"),i=r(a),s=n("./node_modules/gatsby-link/index.js"),l=o(s),c=n("./src/components/Section.js"),u=n("./src/components/Headers.js"),d=n("./src/components/CodeBlock.js");t.default=function(){return i.createElement("div",null,i.createElement(u.PageHeader,null,"Using Plugins"),i.createElement(c.Section,{title:"Introduction"},i.createElement("p",null,"Previously, we looked at ",i.createElement(l.default,{to:"/services-and-controllers"},"services"),", which allow behaviours to be extracted out of controller components and shared."),i.createElement("p",null,"Sometimes, we want to attach behavior to the ",i.createElement("em",null,"whole application"),". Plugins provide a way of doing this. Some uses of Plugins are:"),i.createElement("ul",null,i.createElement("li",null,"When integrating an authentication provider, we might need to retrieve and validate an auth token when the application loads for the first time, before we decide what page to render."),i.createElement("li",null,"When integrating a data store such as Redux, we would need to keep a single store instance at the root of applications and allow our services and controllers access to the store."),i.createElement("li",null,"When writing a controller that interfaces with DOM APIs, we may want to use that controller in environments where the DOM does not exist. For example, a controller that reads or writes to cookies that we wish to use in a server-side-rendered application would need an abstract interface to access cookies, looking in the HTTP request in a server app, or a DOM API in the browser. It might also need a stub implementation when running in a test environment."),i.createElement("li",null,"When writing a GraphQL API for an application, we might want to add a GraphQL endpoint to our application server (assuming that we aren’t using an external GraphQL API).")),i.createElement("p",null,"Plugins provide a simple way of achieving these tasks.")),i.createElement(c.Section,{title:"Using plugins"},i.createElement("p",null,"Plugins are configured in a special file at the root of your application's source, ",i.createElement("code",null,"src/config.ts"),". Let’s look at a hypothetical plugin called ",i.createElement("code",null,"EventManager")," that allows components to post and subscribe to events. We would install the plugin by adding it to the default export of our config file."),i.createElement(d.CodeFile,{path:"src/config.ts"},n("./node_modules/raw-loader/index.js!../examples/plugin-with-injection/src/config.ts")),i.createElement("p",null,"Some plugins provide an API to controllers. Others may have application-wide effects that do not require any usage. Consult the documentation for the specific plugin for further usage instructions.")),i.createElement(c.Section,{title:"Writing plugins that provide injectable dependencies"},i.createElement("p",null,"One usecase for plugins is to configure dependencies that are injected into controllers and services on request."),i.createElement("p",null,"Plugins that allow dependencies to be injected into components will typically provide a decorator to inject the dependency and an interface for the dependency as an API. A controller that uses a hypothetical ",i.createElement("code",null,"EventManager")," plugin to dispatch events might use it as follows:"),i.createElement(d.CodeFile,{path:"src/components/ControlPanel.tsx"},n("./node_modules/raw-loader/index.js!../examples/plugin-with-injection/src/components/ControlPanel.tsx")),i.createElement("p",null,"It is important to understand the difference between injected objects and services. Although the APIs are similar, they serve very different purposes. Objects injected by plugins are shared across the whole application. This differs from services, which are unique to each controller. So for an event system, which requires all clients to share a single underlying object, we would use a plugin to provide the event manager. For a form-binding helper, which is a piece of extracted controller logic, we would use a service."),i.createElement("p",null,"Writing a plugin entails creating a plugin configuration to export the dependencies the plugin provides. This is done by extending the ",i.createElement("code",null,"PluginConfig")," class, and utilising the",i.createElement("code",null,"@exported")," decorator."),i.createElement(d.CodeFile,{path:"src/plugins/EventManagerPlugin.ts"},n("./node_modules/raw-loader/index.js!../examples/plugin-with-injection/src/plugins/EventManagerPlugin.ts")),i.createElement("p",null,"In this code block we have created an extremely simple event manager plugin. The event manager itself is just an object; what's special here is the use of the ",i.createElement("code",null,"@exported")," decorator to allow the ",i.createElement("code",null,"EventManager")," to be injected into controllers and services."),i.createElement("p",null,"The ",i.createElement("code",null,"@exported")," decorator takes one parameter: a string key. This registers the value of the decorated property as an available dependency with the given key. Any controllers or services can request this dependency by providing the same key to the ",i.createElement("code",null,"@inject")," decorator."),i.createElement("p",null,"To abstract the details of the key away from the users of our plugin, we've exported a decorator named",i.createElement("code",null,"@eventManager"),". In this case, this is simply ",i.createElement("code",null,"@inject")," with a prefilled key. This does, however, give us (the plugin authors) the freedom to change how the clients of the plugin receive the EventManager. In the future, we may wish to do more than just a simple inject; we may also wish to utilise ",i.createElement("code",null,"@service")," capabilities, for example.")),i.createElement(c.Section,{title:"Writing plugins that manage application state"},i.createElement("p",null,"Sometimes components need to access and modify state that isn’t scoped to a particular view and is therefore not appropriate to manage using a component or service."),i.createElement("p",null,"A second function of plugins is to allow the management of application-level state, while allowing components to subscribe to state changes using the ",i.createElement("code",null,"@select()")," decorator."),i.createElement("p",null,"The approach used will be familiar to you if you have used ",i.createElement("a",{href:"https://redux.js.org/"},"Redux")," before. ",i.createElement("em",null,"Action")," objects describing a state modification are dispatched, then applied to the previous state using a ",i.createElement("em",null,"reducer")," function. Components subscribe to a part of the application state by applying a ",i.createElement("em",null,"selector")," function to the application's state object."),i.createElement("p",null,"This structured approach to application state is helpful in large applications, as isolating state modification from the rest of the application makes state easier to reason about."),i.createElement("p",null,"In Bright-js-framework, each reducer function manages a discrete part of the application state identified by a key. Reducers are defined as static methods on plugins, decorated with ",i.createElement("code",null,"@state()"),"."),i.createElement(d.CodeFile,{path:"src/plugins/CounterPlugin.ts"},n("./node_modules/raw-loader/index.js!../examples/plugin-with-state/src/plugins/CounterPlugin.ts")),i.createElement("p",null,"A component developer would then use this API as follows:"),i.createElement(d.CodeFile,{path:"src/components/Counter.tsx"},n("./node_modules/raw-loader/index.js!../examples/plugin-with-state/src/components/Counter.tsx"))))},e.exports=t.default},"./node_modules/raw-loader/index.js!../examples/plugin-with-injection/src/components/ControlPanel.tsx":function(e,t){e.exports="import * as React from 'react'\nimport { controller } from '@brightinteractive/bright-js-framework'\nimport { eventManager, EventManager } from '../plugins/EventManagerPlugin'\n\n@controller()\nexport class ControlPanel extends React.PureComponent {\n  @eventManager\n  eventManager: EventManager\n\n  handleOpenClick = () => {\n    this.eventManager.emit('request-open-pod-bay-doors')\n  }\n\n  componentDidMount() {\n    this.eventManager.registerHandler('request-open-pod-bay-doors', () => {\n      console.error('I’m sorry but I can’t do that, Dave')\n    })\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Pod Bay doors:</h3>\n        <button onClick={this.handleOpenClick}>Open</button>\n      </div>\n    )\n  }\n}\n"},"./node_modules/raw-loader/index.js!../examples/plugin-with-injection/src/config.ts":function(e,t){e.exports="import EventManagerPlugin from './plugins/EventManagerPlugin'\n\nexport default [\n  EventManagerPlugin\n]\n"},"./node_modules/raw-loader/index.js!../examples/plugin-with-injection/src/plugins/EventManagerPlugin.ts":function(e,t){e.exports="import {exported, inject, PluginConfig} from '@brightinteractive/bright-js-framework'\n\nconst EVENT_MANAGER = 'eventManager'\n\nexport const eventManager = inject(EVENT_MANAGER)\n\nexport default class EventManagerPlugin extends PluginConfig {\n  @exported(EVENT_MANAGER)\n  eventManager = new EventManager()\n}\n\nexport type EventHandler = (event: any) => void\n\nexport class EventManager {\n  private eventHandlers: Map<string, Set<EventHandler>> = new Map()\n\n  registerHandler(eventKey: string, eventHandler: EventHandler) {\n    const existingHandlers = this.eventHandlers.get(eventKey) || new Set()\n    this.eventHandlers.set(eventKey, existingHandlers.add(eventHandler))\n  }\n\n  emit(eventKey: string, event?: any) {\n    const handlers = this.eventHandlers.get(eventKey)\n    if (!handlers) {\n      return\n    }\n\n    handlers.forEach((eventHandler) => eventHandler(event))\n  }\n}\n"},"./node_modules/raw-loader/index.js!../examples/plugin-with-state/src/components/Counter.tsx":function(e,t){e.exports="import * as React from 'react'\nimport { controller, select, StateSelection } from '@brightinteractive/bright-js-framework'\nimport { CounterActions, counterActions, counterValue } from '../plugins/CounterPlugin'\n\n@controller()\nexport class Counter extends React.PureComponent {\n  @select(counterValue)\n  counterValue: StateSelection<number>\n\n  @counterActions\n  counter: CounterActions\n\n  render() {\n    return (\n      <div>\n        Value: {this.counterValue.value}\n        <button onClick={this.counter.increment}>Increment</button>\n      </div>\n    )\n  }\n}\n"},"./node_modules/raw-loader/index.js!../examples/plugin-with-state/src/plugins/CounterPlugin.ts":function(e,t){e.exports="import { inject, state, exported, dispatcher, Dispatcher, PluginConfig, Action, SelectFn } from '@brightinteractive/bright-js-framework'\n\nconst COUNTER_ACTIONS = 'counterActions'\nconst COUNTER_STATE = 'counter'\n\nexport interface CounterActions {\n  increment(): void\n}\n\ninterface CounterState {\n  counterValue: number\n}\n\nexport default class CounterPlugin extends PluginConfig<CounterState> {\n  @state(COUNTER_STATE)\n  static update(prev: number = 0, action: Action): number {\n    if (action.type === 'counter:increment') {\n      return prev + 1\n    }\n\n    return prev\n  }\n\n  @dispatcher()\n  dispatch: Dispatcher\n\n  @exported(COUNTER_ACTIONS)\n  actions: CounterActions = {\n    increment: () => {\n      this.dispatch({ type: 'counter:increment' })\n    }\n  }\n}\n\n// Exported API to inject the action objects into a service or controller\nexport const counterActions = inject(COUNTER_ACTIONS)\n\n// Exported API to bind a selected state value into a service or controller\nexport const counterValue: SelectFn<number> = (appState) => appState[COUNTER_STATE]\n"}});
//# sourceMappingURL=component---src-pages-docs-extending-with-plugins-js-739ced44057dc2e4c89b.js.map