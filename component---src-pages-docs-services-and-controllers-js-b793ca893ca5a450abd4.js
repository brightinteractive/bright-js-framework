webpackJsonp([0x6f52a7cdbf3c],{310:function(e,t,n){"use strict";function i(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}t.__esModule=!0;var s=n(1),o=i(s),r=n(34),a=n(24),l=n(38);t.default=function(){return o.createElement("div",null,o.createElement(a.PageHeader,null,"Services and Controllers"),o.createElement(r.Section,{title:"Introduction"},o.createElement("p",null,"In React, we are used to thinking about applications as a tree of components."),o.createElement("p",null,"We tend to think of two types of components. 'Controller' components are responsible for fetching data, holding state, connecting to global state, firing off side effects, long-running operations and navigation. 'View' components are largely stateless, with their props passed in by their parent controller."),o.createElement("p",null,"This is nice as it keeps our view components nice and simple and makes them easy to reuse and test. Unfortunately, writing clean, testable controllers is much more difficult. Keeping controller code modular and reusable is also hard."),o.createElement("p",null,"In other frameworks, we might extract a concern out of a large class into separate utility classes. This is difficult in React because of the way that state is required to be owned by a component. These concerns might also need to respond to component lifecycle events or interact with API clients that live in the React context."),o.createElement("p",null,"Bright-js-framework makes it very easy to extract logic out of controllers by introducing the concept of a ",o.createElement("em",null,"Service"),". Services are classes that have access to a subset of the React Component API. They are owned by a parent component, and receive lifecycle events. We'll look at an example of how they can be used in the next section.")),o.createElement(r.Section,{title:"Extracting logic from Controllers"},o.createElement("p",null,"Let's imagine a simple todo list component. In this example, we've split the presentational logic out into the ",o.createElement("code",null,"TodoListView")," component, leaving ",o.createElement("code",null,"TodoList")," to manage the state it presents.  We've excluded the ",o.createElement("code",null,"TodoListView")," source code for brevity (there's nothing special about it), but it can be viewed in the ",o.createElement("a",{href:"https://github.com/brightinteractive/bright-js-framework/tree/master/examples/extracting-services-from-controllers/src/components"},"examples folder on Github"),"."),o.createElement(l.CodeFile,{path:"src/components/TodoList.before.tsx"},n(648)),o.createElement("p",null,"At the moment, it isn't a huge component, but we can imagine that as requirements evolve (for example, if we start adding persistence, search and other features) it might become unwieldy. We might want to use the same update logic in different view contexts, without having to duplicate this logic amongst multiple components."),o.createElement("p",null,"In this example, we will split the list state management concern out into a separate class, leaving the ",o.createElement("code",null,"TodoList")," as a simple component that wires this up to ",o.createElement("code",null,"TodoListView"),"."),o.createElement("p",null,"First, we create a new Service class that contains the state management logic extracted from ",o.createElement("code",null,"TodoList"),":"),o.createElement(l.CodeFile,{path:"src/services/ListService.tsx"},n(649)),o.createElement("p",null,"Next, we annotate the controller with the ",o.createElement("code",null,"@controller")," decorator and replace the state management logic with an instance of our new service. Adding the ",o.createElement("code",null,"@controller")," decorator is important, as otherwise the service won’t be connected to the controller’s state and lifecycle events."),o.createElement(l.CodeFile,{path:"src/components/TodoList.after.tsx"},n(647)),o.createElement("p",null,"The behaviour of this component is identical to the original one, but its implementation is much simpler. Our ",o.createElement("code",null,"ListService")," class is now able to store state, which acts as if it were state of ",o.createElement("code",null,"TodoList"),". Controllers are re-rendered whenever the state of a constituent service changes.")))},e.exports=t.default},647:function(e,t){e.exports="import * as React from 'react'\nimport { controller, service } from '@brightinteractive/bright-js-framework'\nimport { TodoListView } from './TodoListView'\nimport { ListService } from '../services/ListService'\n\n@controller()\nexport class TodoList extends React.PureComponent {\n  @service(ListService)\n  list: ListService\n\n  render() {\n    return (\n      <TodoListView\n        items={this.list.items}\n        onAdd={this.list.handleAdd}\n        onEdit={this.list.handleEdit}\n        onDelete={this.list.handleDelete}\n      />\n    )\n  }\n}\n"},648:function(e,t){e.exports="import * as React from 'react'\nimport { TodoListView } from './TodoListView'\n\nexport interface TodoListProps {\n\n}\n\nexport interface TodoListState {\n  items: string[]\n}\n\nexport class TodoList extends React.PureComponent<TodoListProps, TodoListState> {\n  state: TodoListState = { items: [] }\n\n  handleAdd = (item: string) => {\n    this.setState({\n      items: [...this.state.items, item ]\n    })\n  }\n\n  handleDelete = (index: number) => {\n    const next = this.state.items.slice()\n    next.splice(index, 1)\n\n    this.setState({\n      items: next\n    })\n  }\n\n  handleEdit = (index: number, value: string) => {\n    const next = this.state.items.slice()\n    next[index] = value\n\n    this.setState({\n      items: this.state.items\n    })\n  }\n\n  render() {\n    return (\n      <TodoListView\n        items={this.state.items}\n        onAdd={this.handleAdd}\n        onEdit={this.handleEdit}\n        onDelete={this.handleDelete}\n      />\n    )\n  }\n}\n"},649:function(e,t){e.exports="import { Service } from '@brightinteractive/bright-js-framework'\n\nexport interface ListServiceState {\n  items: string[]\n}\n\nexport class ListService extends Service<ListServiceState> {\n  state: ListServiceState = { items: [] }\n\n  get items() {\n    return this.state.items\n  }\n\n  handleAdd = (item: string) => {\n    this.setState({\n      items: [...this.state.items, item ]\n    })\n  }\n\n  handleDelete = (index: number) => {\n    const next = this.state.items.slice()\n    next.splice(index, 1)\n\n    this.setState({\n      items: next\n    })\n  }\n\n  handleEdit = (index: number, value: string) => {\n    const next = this.state.items.slice()\n    next[index] = value\n\n    this.setState({\n      items: this.state.items\n    })\n  }\n}\n"}});
//# sourceMappingURL=component---src-pages-docs-services-and-controllers-js-b793ca893ca5a450abd4.js.map